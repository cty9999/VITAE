<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>VITAE.inference API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>VITAE.inference</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import warnings

import pandas as pd
import numpy as np
from scipy.interpolate import splrep, splev
import networkx as nx
import umap
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.patheffects as pe

from VITAE.utils import get_embedding, get_smooth_curve

class Inferer(object):
    def __init__(self, NUM_CLUSTER):
        self.NUM_CLUSTER = NUM_CLUSTER
        self.NUM_STATE = int(NUM_CLUSTER*(NUM_CLUSTER+1)/2)
        self.CLUSTER_CENTER = np.array([int((NUM_CLUSTER+(1-i)/2)*i) for i in range(NUM_CLUSTER)])
        self.A, self.B = np.nonzero(np.triu(np.ones(NUM_CLUSTER)))
        self.C = np.triu(np.ones(NUM_CLUSTER))
        self.C[self.C&gt;0] = np.arange(self.NUM_STATE)
        self.C = self.C.astype(int)
        
        
    def build_graphs(self, pc_x, thres=0.5, method=&#39;mean&#39;):
        graph = np.zeros((self.NUM_CLUSTER,self.NUM_CLUSTER))
        if method==&#39;mean&#39;:
            for i in range(self.NUM_CLUSTER-1):
                for j in range(i+1,self.NUM_CLUSTER):
                    idx = np.sum(pc_x[:,self.C[[i,i,j],[i,j,j]]], axis=1)&gt;=thres
                    if np.sum(idx)&gt;0:
                        graph[i,j] = np.mean(pc_x[idx,self.C[i,j]]/np.sum(pc_x[idx][:,self.C[[i,i,j],[i,j,j]]], axis=-1))
        elif method==&#39;modified_mean&#39;:
            for i in range(self.NUM_CLUSTER-1):
                for j in range(i+1,self.NUM_CLUSTER):
                    idx = np.sum(pc_x[:,self.C[[i,i,j],[i,j,j]]], axis=1)&gt;=thres
                    if np.sum(idx)&gt;0:
                        graph[i,j] = np.sum(pc_x[idx,self.C[i,j]])/np.sum(pc_x[idx][:,self.C[[i,i,j],[i,j,j]]])
        elif method==&#39;map&#39;:
            c = np.argmax(pc_x, axis=-1)
            for i in range(self.NUM_CLUSTER-1):
                for j in range(i+1,self.NUM_CLUSTER):
                    if np.sum(c==self.C[i,j])&gt;0:
                        graph[i,j] = np.sum(c==self.C[i,j])/np.sum((c==self.C[i,j])|(c==self.C[i,i])|(c==self.C[j,j]))
        elif method==&#39;modified_map&#39;:
            c = np.argmax(pc_x, axis=-1)
            for i in range(self.NUM_CLUSTER-1):
                for j in range(i+1,self.NUM_CLUSTER):
                    graph[i,j] = np.sum(c==self.C[i,j])/(np.sum((self.w_tilde[:,i]&gt;0.5)|(self.w_tilde[:,j]&gt;0.5))+1e-16)
        else:
            raise ValueError(&#34;Invalid method, must be one of &#39;mean&#39;, &#39;modified_mean&#39;, &#39;map&#39;, and &#39;modified_map&#39;.&#34;)
                    
        G = nx.from_numpy_array(graph)
        
        if self.no_loop and not nx.is_tree(G):
            # prune and merge points if there are loops
            G = nx.maximum_spanning_tree(G)
            
        return G


    def modify_wtilde(self, w_tilde, edges):
        w = np.zeros_like(w_tilde)
        
        # projection on nodes
        best_proj_err_node = np.sum(w_tilde**2, axis=-1) - 2*np.max(w_tilde, axis=-1) +1
        best_proj_err_node_ind = np.argmax(w_tilde, axis=-1)
        
        if len(edges)&gt;0:
            # projection on edges
            idc = np.tile(np.arange(w.shape[0]), (2,1)).T
            ide = edges[np.argmax(np.sum(w_tilde[:,edges], axis=-1)**2 -
                                  4 * np.prod(w_tilde[:,edges], axis=-1) +
                                  2 * np.sum(w_tilde[:,edges], axis=-1), axis=-1)]
            w[idc, ide] = w_tilde[idc, ide] + (1-np.sum(w_tilde[idc, ide], axis=-1, keepdims=True))/2
            best_proj_err_edge = np.sum(w_tilde**2, axis=-1) - np.sum(w_tilde[idc, ide]**2, axis=-1) + (1-np.sum(w_tilde[idc, ide], axis=-1))**2/2
                         
            idc = (best_proj_err_node&lt;best_proj_err_edge)
            w[idc,:] = np.eye(w_tilde.shape[-1])[best_proj_err_node_ind[idc]]
        else:
            idc = np.arange(w.shape[0])
            w[idc, best_proj_err_node_ind] = 1
        return w


    def init_inference(self, w_tilde, pc_x, thres=0.5, method=&#39;mean&#39;, no_loop=False):
        self.no_loop = no_loop
        self.w_tilde = w_tilde
        
        # Build graph
        self.G = self.build_graphs(pc_x, thres=thres, method=method)
        
        edges = np.array(list(self.G.edges))
        self.edges = [self.C[edges[i,0], edges[i,1]] for i in range(len(edges))]

        return self.G, self.edges
        
    
    def init_embedding(self, z, mu, dimred=&#39;umap&#39;, **kwargs):
        self.mu = mu.copy()
        concate_z = np.concatenate((z, mu.T), axis=0)
        embed = get_embedding(concate_z, dimred, **kwargs)
        
        self.embed_z = embed[:-self.NUM_CLUSTER,:]
        self.embed_mu = embed[-self.NUM_CLUSTER:,:]
        return self.embed_z.copy()
        
        
    def plot_clusters(self, labels, path=None):
        if labels is None:
            print(&#39;No clustering labels available!&#39;)
        else:
            n_labels = len(np.unique(labels))
            colors = [plt.cm.jet(float(i)/n_labels) for i in range(n_labels)]
            
            fig, ax = plt.subplots(1,1, figsize=(20, 10))
            for i,x in enumerate(np.unique(labels)):
                ax.scatter(*self.embed_z[labels==x].T, c=[colors[i]],
                    s=8, alpha=0.6, label=str(x))
                ax.text(np.mean(self.embed_z[labels==x,0]), 
                        np.mean(self.embed_z[labels==x,1]), str(x), fontsize=16)
            box = ax.get_position()
            ax.set_position([box.x0, box.y0 + box.height * 0.1,
                             box.width, box.height * 0.9])
            ax.legend(loc=&#39;upper center&#39;, bbox_to_anchor=(0.5, -0.05),
                      fancybox=True, shadow=True, markerscale=5, ncol=5)
            ax.set_title(&#39;Cluster Membership&#39;)
            plt.setp(ax, xticks=[], yticks=[])
            if path is not None:
                plt.savefig(path, dpi=300)
            plt.show()
        return None
        
    def build_milestone_net(self, subgraph, init_node):
        &#39;&#39;&#39;
        Args:
            subgraph     - a connected component of the graph, csr_matrix
            init_node    - root node
        Returns:
            df_subgraph  - dataframe of milestone network
        &#39;&#39;&#39;

        if len(subgraph)==1:
            warnings.warn(&#39;Singular node.&#39;)
            return []
        else:
            # Dijkstra&#39;s Algorithm
            unvisited = {node: {&#39;parent&#39;:None,
                                &#39;score&#39;:np.inf,
                                &#39;distance&#39;:np.inf} for node in subgraph.nodes}
            current = init_node
            currentScore = 0
            currentDistance = 0
            unvisited[current][&#39;score&#39;] = currentScore

            milestone_net = []
            while True:
                for neighbour in subgraph.neighbors(current):
                    if neighbour not in unvisited: continue
                    newScore = currentScore + subgraph[current][neighbour][&#39;weight&#39;]
                    if unvisited[neighbour][&#39;score&#39;] &gt; newScore:
                        unvisited[neighbour][&#39;score&#39;] = newScore
                        unvisited[neighbour][&#39;parent&#39;] = current
                        unvisited[neighbour][&#39;distance&#39;] = currentDistance+1

                if len(unvisited)&lt;len(subgraph):
                    milestone_net.append([unvisited[current][&#39;parent&#39;],
                                          current,
                                          unvisited[current][&#39;distance&#39;]])
                del unvisited[current]
                if not unvisited: break
                current, currentScore, currentDistance = \
                    sorted([(i[0],i[1][&#39;score&#39;],i[1][&#39;distance&#39;]) for i in unvisited.items()],
                            key = lambda x: x[1])[0]
            return np.array(milestone_net)
    
    
    def comp_pseudotime(self, milestone_net, init_node, w):
        pseudotime = - np.ones(w.shape[0])
        pseudotime[w[:,init_node]==1] = 0
        
        if len(milestone_net)&gt;0:
            for i in range(len(milestone_net)):
                _from, _to = milestone_net[i,:2]
                _from, _to = int(_from), int(_to)

                idc = ((w[:,_from]&gt;0)&amp;(w[:,_to]&gt;0)) | (w[:,_to]==1)
                pseudotime[idc] = w[idc,_to] + milestone_net[i,-1] - 1
        
        return pseudotime


    def infer_trajectory(self, init_node, labels=None, cutoff=None, is_plot=True, path=None):
        &#39;&#39;&#39;
        Params:
            init_node  - (int) the initial node for the inferred trajectory.
            labels     - (numpy.array) labels of cells, used for plotting.
            cutoff     - (string) threshold for filtering edges with scores less than cutoff.
            is_plot    - (boolean) if is_plot is True and labels are given, two plots of the
                         groupings and the pseudotimes will be displayed; if is_plot is True
                         and labels are None, only the plot of pseudotime will be displayed.
            path       - (string) path to save figure, or don&#39;t save if it is None.
        Returns:
            G          - (networkx.Graph) modified graph that indicates the inferred trajectory
            w          - (numpy.array) modified w_tilde
            pseudotime - (numpy.array) pseudotime based on projected trajectory
        &#39;&#39;&#39;
        # select edges
        if len(self.edges)==0:
            select_edges = []
            G = nx.Graph()
            G.add_nodes_from(self.G.nodes)
        else:
            if self.no_loop:
                G = nx.maximum_spanning_tree(self.G)
            else:
                G = self.G
            if cutoff is None:
                cutoff = 0.01
            graph = nx.to_numpy_matrix(G)
            graph[graph&lt;=cutoff] = 0
            G = nx.from_numpy_array(graph)
            connected_comps = nx.node_connected_component(G, init_node)
            subG = G.subgraph(connected_comps)
            if len(subG.edges)&gt;0:                
                milestone_net = self.build_milestone_net(subG,init_node)
                select_edges = milestone_net[:,:2]
                select_edges_score = graph[select_edges[:,0], select_edges[:,1]]
                if select_edges_score.max() - select_edges_score.min() == 0:
                    select_edges_score = select_edges_score/select_edges_score.max()
                else:
                    select_edges_score = (select_edges_score - select_edges_score.min())/(select_edges_score.max() - select_edges_score.min())*3                    
            else:
                milestone_net = select_edges = []                    
        
        # modify w_tilde
        w = self.modify_wtilde(self.w_tilde, select_edges)
        
        # compute pseudotime
        pseudotime = self.comp_pseudotime(milestone_net, init_node, w)
        
        if is_plot:
            fig, ax = plt.subplots(1,1, figsize=(20, 10))
                
            cmap = matplotlib.cm.get_cmap(&#39;viridis&#39;)
            colors = [plt.cm.jet(float(i)/self.NUM_CLUSTER) for i in range(self.NUM_CLUSTER)]
            if np.sum(pseudotime&gt;-1)&gt;0:
                norm = matplotlib.colors.Normalize(vmin=np.min(pseudotime[pseudotime&gt;-1]), vmax=np.max(pseudotime))
                sc = ax.scatter(*self.embed_z[pseudotime&gt;-1,:].T,
                    norm=norm,
                    c=pseudotime[pseudotime&gt;-1],
                    s=8, alpha=0.5)
                plt.colorbar(sc, ax=[ax], location=&#39;right&#39;)
            else:
                norm = None
                
            if np.sum(pseudotime==-1)&gt;0:
                ax.scatter(*self.embed_z[pseudotime==-1,:].T,
                            c=&#39;gray&#39;, s=8, alpha=0.4)
            
            for i in range(len(select_edges)):
                points = self.embed_z[np.sum(w[:,select_edges[i,:]]&gt;0, axis=-1)==2,:]
                points = points[points[:,0].argsort()]                
                try:
                    x_smooth, y_smooth = get_smooth_curve(
                        points, 
                        self.embed_mu[select_edges[i,:], :]
                        )
                except:
                    x_smooth, y_smooth = self.embed_mu[select_edges[i,:], 0], self.embed_mu[select_edges[i,:], 1]
                ax.plot(x_smooth, y_smooth, 
                    &#39;-&#39;, 
                    linewidth= 1 + select_edges_score[0,i],
                    color=&#34;black&#34;, 
                    alpha=0.8, 
                    path_effects=[pe.Stroke(linewidth=1+select_edges_score[0,i]+1.5, 
                                            foreground=&#39;white&#39;), pe.Normal()],
                    zorder=1
                    )

                delta_x = self.embed_mu[select_edges[i,1], 0]-x_smooth[-2]
                delta_y = self.embed_mu[select_edges[i,1], 1]-y_smooth[-2]
                length = np.sqrt(delta_x**2 + delta_y**2) * 1.5                
                ax.arrow(
                        self.embed_mu[select_edges[i,1], 0]-delta_x/length, 
                        self.embed_mu[select_edges[i,1], 1]-delta_y/length, 
                        delta_x/length,
                        delta_y/length,
                        color=&#39;black&#39;, alpha=1.0,
                        shape=&#39;full&#39;, lw=0, length_includes_head=True, head_width=0.4, zorder=2)
            
            for i in range(len(self.CLUSTER_CENTER)):
                ax.scatter(*self.embed_mu[i:i+1,:].T, c=[colors[i]],
                            edgecolors=&#39;white&#39;, # linewidths=10,
                            norm=norm,
                            s=250, marker=&#39;*&#39;, label=str(i))
                ax.text(self.embed_mu[i,0], self.embed_mu[i,1], &#39;%02d&#39;%i, fontsize=16)
                
            plt.setp(ax, xticks=[], yticks=[])
            box = ax.get_position()
            ax.set_position([box.x0, box.y0 + box.height * 0.1,
                                box.width, box.height * 0.9])
            ax.legend(loc=&#39;upper center&#39;, bbox_to_anchor=(0.5, -0.05),
                fancybox=True, shadow=True, ncol=5)
            
            ax.set_title(&#39;Trajectory&#39;)
            if path is not None:
                plt.savefig(path, dpi=300)
            plt.show()
        return G, w, pseudotime
            </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="VITAE.inference.Inferer"><code class="flex name class">
<span>class <span class="ident">Inferer</span></span>
<span>(</span><span>NUM_CLUSTER)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Inferer(object):
    def __init__(self, NUM_CLUSTER):
        self.NUM_CLUSTER = NUM_CLUSTER
        self.NUM_STATE = int(NUM_CLUSTER*(NUM_CLUSTER+1)/2)
        self.CLUSTER_CENTER = np.array([int((NUM_CLUSTER+(1-i)/2)*i) for i in range(NUM_CLUSTER)])
        self.A, self.B = np.nonzero(np.triu(np.ones(NUM_CLUSTER)))
        self.C = np.triu(np.ones(NUM_CLUSTER))
        self.C[self.C&gt;0] = np.arange(self.NUM_STATE)
        self.C = self.C.astype(int)
        
        
    def build_graphs(self, pc_x, thres=0.5, method=&#39;mean&#39;):
        graph = np.zeros((self.NUM_CLUSTER,self.NUM_CLUSTER))
        if method==&#39;mean&#39;:
            for i in range(self.NUM_CLUSTER-1):
                for j in range(i+1,self.NUM_CLUSTER):
                    idx = np.sum(pc_x[:,self.C[[i,i,j],[i,j,j]]], axis=1)&gt;=thres
                    if np.sum(idx)&gt;0:
                        graph[i,j] = np.mean(pc_x[idx,self.C[i,j]]/np.sum(pc_x[idx][:,self.C[[i,i,j],[i,j,j]]], axis=-1))
        elif method==&#39;modified_mean&#39;:
            for i in range(self.NUM_CLUSTER-1):
                for j in range(i+1,self.NUM_CLUSTER):
                    idx = np.sum(pc_x[:,self.C[[i,i,j],[i,j,j]]], axis=1)&gt;=thres
                    if np.sum(idx)&gt;0:
                        graph[i,j] = np.sum(pc_x[idx,self.C[i,j]])/np.sum(pc_x[idx][:,self.C[[i,i,j],[i,j,j]]])
        elif method==&#39;map&#39;:
            c = np.argmax(pc_x, axis=-1)
            for i in range(self.NUM_CLUSTER-1):
                for j in range(i+1,self.NUM_CLUSTER):
                    if np.sum(c==self.C[i,j])&gt;0:
                        graph[i,j] = np.sum(c==self.C[i,j])/np.sum((c==self.C[i,j])|(c==self.C[i,i])|(c==self.C[j,j]))
        elif method==&#39;modified_map&#39;:
            c = np.argmax(pc_x, axis=-1)
            for i in range(self.NUM_CLUSTER-1):
                for j in range(i+1,self.NUM_CLUSTER):
                    graph[i,j] = np.sum(c==self.C[i,j])/(np.sum((self.w_tilde[:,i]&gt;0.5)|(self.w_tilde[:,j]&gt;0.5))+1e-16)
        else:
            raise ValueError(&#34;Invalid method, must be one of &#39;mean&#39;, &#39;modified_mean&#39;, &#39;map&#39;, and &#39;modified_map&#39;.&#34;)
                    
        G = nx.from_numpy_array(graph)
        
        if self.no_loop and not nx.is_tree(G):
            # prune and merge points if there are loops
            G = nx.maximum_spanning_tree(G)
            
        return G


    def modify_wtilde(self, w_tilde, edges):
        w = np.zeros_like(w_tilde)
        
        # projection on nodes
        best_proj_err_node = np.sum(w_tilde**2, axis=-1) - 2*np.max(w_tilde, axis=-1) +1
        best_proj_err_node_ind = np.argmax(w_tilde, axis=-1)
        
        if len(edges)&gt;0:
            # projection on edges
            idc = np.tile(np.arange(w.shape[0]), (2,1)).T
            ide = edges[np.argmax(np.sum(w_tilde[:,edges], axis=-1)**2 -
                                  4 * np.prod(w_tilde[:,edges], axis=-1) +
                                  2 * np.sum(w_tilde[:,edges], axis=-1), axis=-1)]
            w[idc, ide] = w_tilde[idc, ide] + (1-np.sum(w_tilde[idc, ide], axis=-1, keepdims=True))/2
            best_proj_err_edge = np.sum(w_tilde**2, axis=-1) - np.sum(w_tilde[idc, ide]**2, axis=-1) + (1-np.sum(w_tilde[idc, ide], axis=-1))**2/2
                         
            idc = (best_proj_err_node&lt;best_proj_err_edge)
            w[idc,:] = np.eye(w_tilde.shape[-1])[best_proj_err_node_ind[idc]]
        else:
            idc = np.arange(w.shape[0])
            w[idc, best_proj_err_node_ind] = 1
        return w


    def init_inference(self, w_tilde, pc_x, thres=0.5, method=&#39;mean&#39;, no_loop=False):
        self.no_loop = no_loop
        self.w_tilde = w_tilde
        
        # Build graph
        self.G = self.build_graphs(pc_x, thres=thres, method=method)
        
        edges = np.array(list(self.G.edges))
        self.edges = [self.C[edges[i,0], edges[i,1]] for i in range(len(edges))]

        return self.G, self.edges
        
    
    def init_embedding(self, z, mu, dimred=&#39;umap&#39;, **kwargs):
        self.mu = mu.copy()
        concate_z = np.concatenate((z, mu.T), axis=0)
        embed = get_embedding(concate_z, dimred, **kwargs)
        
        self.embed_z = embed[:-self.NUM_CLUSTER,:]
        self.embed_mu = embed[-self.NUM_CLUSTER:,:]
        return self.embed_z.copy()
        
        
    def plot_clusters(self, labels, path=None):
        if labels is None:
            print(&#39;No clustering labels available!&#39;)
        else:
            n_labels = len(np.unique(labels))
            colors = [plt.cm.jet(float(i)/n_labels) for i in range(n_labels)]
            
            fig, ax = plt.subplots(1,1, figsize=(20, 10))
            for i,x in enumerate(np.unique(labels)):
                ax.scatter(*self.embed_z[labels==x].T, c=[colors[i]],
                    s=8, alpha=0.6, label=str(x))
                ax.text(np.mean(self.embed_z[labels==x,0]), 
                        np.mean(self.embed_z[labels==x,1]), str(x), fontsize=16)
            box = ax.get_position()
            ax.set_position([box.x0, box.y0 + box.height * 0.1,
                             box.width, box.height * 0.9])
            ax.legend(loc=&#39;upper center&#39;, bbox_to_anchor=(0.5, -0.05),
                      fancybox=True, shadow=True, markerscale=5, ncol=5)
            ax.set_title(&#39;Cluster Membership&#39;)
            plt.setp(ax, xticks=[], yticks=[])
            if path is not None:
                plt.savefig(path, dpi=300)
            plt.show()
        return None
        
    def build_milestone_net(self, subgraph, init_node):
        &#39;&#39;&#39;
        Args:
            subgraph     - a connected component of the graph, csr_matrix
            init_node    - root node
        Returns:
            df_subgraph  - dataframe of milestone network
        &#39;&#39;&#39;

        if len(subgraph)==1:
            warnings.warn(&#39;Singular node.&#39;)
            return []
        else:
            # Dijkstra&#39;s Algorithm
            unvisited = {node: {&#39;parent&#39;:None,
                                &#39;score&#39;:np.inf,
                                &#39;distance&#39;:np.inf} for node in subgraph.nodes}
            current = init_node
            currentScore = 0
            currentDistance = 0
            unvisited[current][&#39;score&#39;] = currentScore

            milestone_net = []
            while True:
                for neighbour in subgraph.neighbors(current):
                    if neighbour not in unvisited: continue
                    newScore = currentScore + subgraph[current][neighbour][&#39;weight&#39;]
                    if unvisited[neighbour][&#39;score&#39;] &gt; newScore:
                        unvisited[neighbour][&#39;score&#39;] = newScore
                        unvisited[neighbour][&#39;parent&#39;] = current
                        unvisited[neighbour][&#39;distance&#39;] = currentDistance+1

                if len(unvisited)&lt;len(subgraph):
                    milestone_net.append([unvisited[current][&#39;parent&#39;],
                                          current,
                                          unvisited[current][&#39;distance&#39;]])
                del unvisited[current]
                if not unvisited: break
                current, currentScore, currentDistance = \
                    sorted([(i[0],i[1][&#39;score&#39;],i[1][&#39;distance&#39;]) for i in unvisited.items()],
                            key = lambda x: x[1])[0]
            return np.array(milestone_net)
    
    
    def comp_pseudotime(self, milestone_net, init_node, w):
        pseudotime = - np.ones(w.shape[0])
        pseudotime[w[:,init_node]==1] = 0
        
        if len(milestone_net)&gt;0:
            for i in range(len(milestone_net)):
                _from, _to = milestone_net[i,:2]
                _from, _to = int(_from), int(_to)

                idc = ((w[:,_from]&gt;0)&amp;(w[:,_to]&gt;0)) | (w[:,_to]==1)
                pseudotime[idc] = w[idc,_to] + milestone_net[i,-1] - 1
        
        return pseudotime


    def infer_trajectory(self, init_node, labels=None, cutoff=None, is_plot=True, path=None):
        &#39;&#39;&#39;
        Params:
            init_node  - (int) the initial node for the inferred trajectory.
            labels     - (numpy.array) labels of cells, used for plotting.
            cutoff     - (string) threshold for filtering edges with scores less than cutoff.
            is_plot    - (boolean) if is_plot is True and labels are given, two plots of the
                         groupings and the pseudotimes will be displayed; if is_plot is True
                         and labels are None, only the plot of pseudotime will be displayed.
            path       - (string) path to save figure, or don&#39;t save if it is None.
        Returns:
            G          - (networkx.Graph) modified graph that indicates the inferred trajectory
            w          - (numpy.array) modified w_tilde
            pseudotime - (numpy.array) pseudotime based on projected trajectory
        &#39;&#39;&#39;
        # select edges
        if len(self.edges)==0:
            select_edges = []
            G = nx.Graph()
            G.add_nodes_from(self.G.nodes)
        else:
            if self.no_loop:
                G = nx.maximum_spanning_tree(self.G)
            else:
                G = self.G
            if cutoff is None:
                cutoff = 0.01
            graph = nx.to_numpy_matrix(G)
            graph[graph&lt;=cutoff] = 0
            G = nx.from_numpy_array(graph)
            connected_comps = nx.node_connected_component(G, init_node)
            subG = G.subgraph(connected_comps)
            if len(subG.edges)&gt;0:                
                milestone_net = self.build_milestone_net(subG,init_node)
                select_edges = milestone_net[:,:2]
                select_edges_score = graph[select_edges[:,0], select_edges[:,1]]
                if select_edges_score.max() - select_edges_score.min() == 0:
                    select_edges_score = select_edges_score/select_edges_score.max()
                else:
                    select_edges_score = (select_edges_score - select_edges_score.min())/(select_edges_score.max() - select_edges_score.min())*3                    
            else:
                milestone_net = select_edges = []                    
        
        # modify w_tilde
        w = self.modify_wtilde(self.w_tilde, select_edges)
        
        # compute pseudotime
        pseudotime = self.comp_pseudotime(milestone_net, init_node, w)
        
        if is_plot:
            fig, ax = plt.subplots(1,1, figsize=(20, 10))
                
            cmap = matplotlib.cm.get_cmap(&#39;viridis&#39;)
            colors = [plt.cm.jet(float(i)/self.NUM_CLUSTER) for i in range(self.NUM_CLUSTER)]
            if np.sum(pseudotime&gt;-1)&gt;0:
                norm = matplotlib.colors.Normalize(vmin=np.min(pseudotime[pseudotime&gt;-1]), vmax=np.max(pseudotime))
                sc = ax.scatter(*self.embed_z[pseudotime&gt;-1,:].T,
                    norm=norm,
                    c=pseudotime[pseudotime&gt;-1],
                    s=8, alpha=0.5)
                plt.colorbar(sc, ax=[ax], location=&#39;right&#39;)
            else:
                norm = None
                
            if np.sum(pseudotime==-1)&gt;0:
                ax.scatter(*self.embed_z[pseudotime==-1,:].T,
                            c=&#39;gray&#39;, s=8, alpha=0.4)
            
            for i in range(len(select_edges)):
                points = self.embed_z[np.sum(w[:,select_edges[i,:]]&gt;0, axis=-1)==2,:]
                points = points[points[:,0].argsort()]                
                try:
                    x_smooth, y_smooth = get_smooth_curve(
                        points, 
                        self.embed_mu[select_edges[i,:], :]
                        )
                except:
                    x_smooth, y_smooth = self.embed_mu[select_edges[i,:], 0], self.embed_mu[select_edges[i,:], 1]
                ax.plot(x_smooth, y_smooth, 
                    &#39;-&#39;, 
                    linewidth= 1 + select_edges_score[0,i],
                    color=&#34;black&#34;, 
                    alpha=0.8, 
                    path_effects=[pe.Stroke(linewidth=1+select_edges_score[0,i]+1.5, 
                                            foreground=&#39;white&#39;), pe.Normal()],
                    zorder=1
                    )

                delta_x = self.embed_mu[select_edges[i,1], 0]-x_smooth[-2]
                delta_y = self.embed_mu[select_edges[i,1], 1]-y_smooth[-2]
                length = np.sqrt(delta_x**2 + delta_y**2) * 1.5                
                ax.arrow(
                        self.embed_mu[select_edges[i,1], 0]-delta_x/length, 
                        self.embed_mu[select_edges[i,1], 1]-delta_y/length, 
                        delta_x/length,
                        delta_y/length,
                        color=&#39;black&#39;, alpha=1.0,
                        shape=&#39;full&#39;, lw=0, length_includes_head=True, head_width=0.4, zorder=2)
            
            for i in range(len(self.CLUSTER_CENTER)):
                ax.scatter(*self.embed_mu[i:i+1,:].T, c=[colors[i]],
                            edgecolors=&#39;white&#39;, # linewidths=10,
                            norm=norm,
                            s=250, marker=&#39;*&#39;, label=str(i))
                ax.text(self.embed_mu[i,0], self.embed_mu[i,1], &#39;%02d&#39;%i, fontsize=16)
                
            plt.setp(ax, xticks=[], yticks=[])
            box = ax.get_position()
            ax.set_position([box.x0, box.y0 + box.height * 0.1,
                                box.width, box.height * 0.9])
            ax.legend(loc=&#39;upper center&#39;, bbox_to_anchor=(0.5, -0.05),
                fancybox=True, shadow=True, ncol=5)
            
            ax.set_title(&#39;Trajectory&#39;)
            if path is not None:
                plt.savefig(path, dpi=300)
            plt.show()
        return G, w, pseudotime</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="VITAE.inference.Inferer.build_graphs"><code class="name flex">
<span>def <span class="ident">build_graphs</span></span>(<span>self, pc_x, thres=0.5, method='mean')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_graphs(self, pc_x, thres=0.5, method=&#39;mean&#39;):
    graph = np.zeros((self.NUM_CLUSTER,self.NUM_CLUSTER))
    if method==&#39;mean&#39;:
        for i in range(self.NUM_CLUSTER-1):
            for j in range(i+1,self.NUM_CLUSTER):
                idx = np.sum(pc_x[:,self.C[[i,i,j],[i,j,j]]], axis=1)&gt;=thres
                if np.sum(idx)&gt;0:
                    graph[i,j] = np.mean(pc_x[idx,self.C[i,j]]/np.sum(pc_x[idx][:,self.C[[i,i,j],[i,j,j]]], axis=-1))
    elif method==&#39;modified_mean&#39;:
        for i in range(self.NUM_CLUSTER-1):
            for j in range(i+1,self.NUM_CLUSTER):
                idx = np.sum(pc_x[:,self.C[[i,i,j],[i,j,j]]], axis=1)&gt;=thres
                if np.sum(idx)&gt;0:
                    graph[i,j] = np.sum(pc_x[idx,self.C[i,j]])/np.sum(pc_x[idx][:,self.C[[i,i,j],[i,j,j]]])
    elif method==&#39;map&#39;:
        c = np.argmax(pc_x, axis=-1)
        for i in range(self.NUM_CLUSTER-1):
            for j in range(i+1,self.NUM_CLUSTER):
                if np.sum(c==self.C[i,j])&gt;0:
                    graph[i,j] = np.sum(c==self.C[i,j])/np.sum((c==self.C[i,j])|(c==self.C[i,i])|(c==self.C[j,j]))
    elif method==&#39;modified_map&#39;:
        c = np.argmax(pc_x, axis=-1)
        for i in range(self.NUM_CLUSTER-1):
            for j in range(i+1,self.NUM_CLUSTER):
                graph[i,j] = np.sum(c==self.C[i,j])/(np.sum((self.w_tilde[:,i]&gt;0.5)|(self.w_tilde[:,j]&gt;0.5))+1e-16)
    else:
        raise ValueError(&#34;Invalid method, must be one of &#39;mean&#39;, &#39;modified_mean&#39;, &#39;map&#39;, and &#39;modified_map&#39;.&#34;)
                
    G = nx.from_numpy_array(graph)
    
    if self.no_loop and not nx.is_tree(G):
        # prune and merge points if there are loops
        G = nx.maximum_spanning_tree(G)
        
    return G</code></pre>
</details>
</dd>
<dt id="VITAE.inference.Inferer.modify_wtilde"><code class="name flex">
<span>def <span class="ident">modify_wtilde</span></span>(<span>self, w_tilde, edges)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def modify_wtilde(self, w_tilde, edges):
    w = np.zeros_like(w_tilde)
    
    # projection on nodes
    best_proj_err_node = np.sum(w_tilde**2, axis=-1) - 2*np.max(w_tilde, axis=-1) +1
    best_proj_err_node_ind = np.argmax(w_tilde, axis=-1)
    
    if len(edges)&gt;0:
        # projection on edges
        idc = np.tile(np.arange(w.shape[0]), (2,1)).T
        ide = edges[np.argmax(np.sum(w_tilde[:,edges], axis=-1)**2 -
                              4 * np.prod(w_tilde[:,edges], axis=-1) +
                              2 * np.sum(w_tilde[:,edges], axis=-1), axis=-1)]
        w[idc, ide] = w_tilde[idc, ide] + (1-np.sum(w_tilde[idc, ide], axis=-1, keepdims=True))/2
        best_proj_err_edge = np.sum(w_tilde**2, axis=-1) - np.sum(w_tilde[idc, ide]**2, axis=-1) + (1-np.sum(w_tilde[idc, ide], axis=-1))**2/2
                     
        idc = (best_proj_err_node&lt;best_proj_err_edge)
        w[idc,:] = np.eye(w_tilde.shape[-1])[best_proj_err_node_ind[idc]]
    else:
        idc = np.arange(w.shape[0])
        w[idc, best_proj_err_node_ind] = 1
    return w</code></pre>
</details>
</dd>
<dt id="VITAE.inference.Inferer.init_inference"><code class="name flex">
<span>def <span class="ident">init_inference</span></span>(<span>self, w_tilde, pc_x, thres=0.5, method='mean', no_loop=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_inference(self, w_tilde, pc_x, thres=0.5, method=&#39;mean&#39;, no_loop=False):
    self.no_loop = no_loop
    self.w_tilde = w_tilde
    
    # Build graph
    self.G = self.build_graphs(pc_x, thres=thres, method=method)
    
    edges = np.array(list(self.G.edges))
    self.edges = [self.C[edges[i,0], edges[i,1]] for i in range(len(edges))]

    return self.G, self.edges</code></pre>
</details>
</dd>
<dt id="VITAE.inference.Inferer.init_embedding"><code class="name flex">
<span>def <span class="ident">init_embedding</span></span>(<span>self, z, mu, dimred='umap', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_embedding(self, z, mu, dimred=&#39;umap&#39;, **kwargs):
    self.mu = mu.copy()
    concate_z = np.concatenate((z, mu.T), axis=0)
    embed = get_embedding(concate_z, dimred, **kwargs)
    
    self.embed_z = embed[:-self.NUM_CLUSTER,:]
    self.embed_mu = embed[-self.NUM_CLUSTER:,:]
    return self.embed_z.copy()</code></pre>
</details>
</dd>
<dt id="VITAE.inference.Inferer.plot_clusters"><code class="name flex">
<span>def <span class="ident">plot_clusters</span></span>(<span>self, labels, path=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_clusters(self, labels, path=None):
    if labels is None:
        print(&#39;No clustering labels available!&#39;)
    else:
        n_labels = len(np.unique(labels))
        colors = [plt.cm.jet(float(i)/n_labels) for i in range(n_labels)]
        
        fig, ax = plt.subplots(1,1, figsize=(20, 10))
        for i,x in enumerate(np.unique(labels)):
            ax.scatter(*self.embed_z[labels==x].T, c=[colors[i]],
                s=8, alpha=0.6, label=str(x))
            ax.text(np.mean(self.embed_z[labels==x,0]), 
                    np.mean(self.embed_z[labels==x,1]), str(x), fontsize=16)
        box = ax.get_position()
        ax.set_position([box.x0, box.y0 + box.height * 0.1,
                         box.width, box.height * 0.9])
        ax.legend(loc=&#39;upper center&#39;, bbox_to_anchor=(0.5, -0.05),
                  fancybox=True, shadow=True, markerscale=5, ncol=5)
        ax.set_title(&#39;Cluster Membership&#39;)
        plt.setp(ax, xticks=[], yticks=[])
        if path is not None:
            plt.savefig(path, dpi=300)
        plt.show()
    return None</code></pre>
</details>
</dd>
<dt id="VITAE.inference.Inferer.build_milestone_net"><code class="name flex">
<span>def <span class="ident">build_milestone_net</span></span>(<span>self, subgraph, init_node)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>subgraph
- a connected component of the graph, csr_matrix
init_node
- root node</p>
<h2 id="returns">Returns</h2>
<p>df_subgraph
- dataframe of milestone network</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_milestone_net(self, subgraph, init_node):
    &#39;&#39;&#39;
    Args:
        subgraph     - a connected component of the graph, csr_matrix
        init_node    - root node
    Returns:
        df_subgraph  - dataframe of milestone network
    &#39;&#39;&#39;

    if len(subgraph)==1:
        warnings.warn(&#39;Singular node.&#39;)
        return []
    else:
        # Dijkstra&#39;s Algorithm
        unvisited = {node: {&#39;parent&#39;:None,
                            &#39;score&#39;:np.inf,
                            &#39;distance&#39;:np.inf} for node in subgraph.nodes}
        current = init_node
        currentScore = 0
        currentDistance = 0
        unvisited[current][&#39;score&#39;] = currentScore

        milestone_net = []
        while True:
            for neighbour in subgraph.neighbors(current):
                if neighbour not in unvisited: continue
                newScore = currentScore + subgraph[current][neighbour][&#39;weight&#39;]
                if unvisited[neighbour][&#39;score&#39;] &gt; newScore:
                    unvisited[neighbour][&#39;score&#39;] = newScore
                    unvisited[neighbour][&#39;parent&#39;] = current
                    unvisited[neighbour][&#39;distance&#39;] = currentDistance+1

            if len(unvisited)&lt;len(subgraph):
                milestone_net.append([unvisited[current][&#39;parent&#39;],
                                      current,
                                      unvisited[current][&#39;distance&#39;]])
            del unvisited[current]
            if not unvisited: break
            current, currentScore, currentDistance = \
                sorted([(i[0],i[1][&#39;score&#39;],i[1][&#39;distance&#39;]) for i in unvisited.items()],
                        key = lambda x: x[1])[0]
        return np.array(milestone_net)</code></pre>
</details>
</dd>
<dt id="VITAE.inference.Inferer.comp_pseudotime"><code class="name flex">
<span>def <span class="ident">comp_pseudotime</span></span>(<span>self, milestone_net, init_node, w)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comp_pseudotime(self, milestone_net, init_node, w):
    pseudotime = - np.ones(w.shape[0])
    pseudotime[w[:,init_node]==1] = 0
    
    if len(milestone_net)&gt;0:
        for i in range(len(milestone_net)):
            _from, _to = milestone_net[i,:2]
            _from, _to = int(_from), int(_to)

            idc = ((w[:,_from]&gt;0)&amp;(w[:,_to]&gt;0)) | (w[:,_to]==1)
            pseudotime[idc] = w[idc,_to] + milestone_net[i,-1] - 1
    
    return pseudotime</code></pre>
</details>
</dd>
<dt id="VITAE.inference.Inferer.infer_trajectory"><code class="name flex">
<span>def <span class="ident">infer_trajectory</span></span>(<span>self, init_node, labels=None, cutoff=None, is_plot=True, path=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="params">Params</h2>
<p>init_node
- (int) the initial node for the inferred trajectory.
labels
- (numpy.array) labels of cells, used for plotting.
cutoff
- (string) threshold for filtering edges with scores less than cutoff.
is_plot
- (boolean) if is_plot is True and labels are given, two plots of the
groupings and the pseudotimes will be displayed; if is_plot is True
and labels are None, only the plot of pseudotime will be displayed.
path
- (string) path to save figure, or don't save if it is None.</p>
<h2 id="returns">Returns</h2>
<p>G
- (networkx.Graph) modified graph that indicates the inferred trajectory
w
- (numpy.array) modified w_tilde
pseudotime - (numpy.array) pseudotime based on projected trajectory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def infer_trajectory(self, init_node, labels=None, cutoff=None, is_plot=True, path=None):
    &#39;&#39;&#39;
    Params:
        init_node  - (int) the initial node for the inferred trajectory.
        labels     - (numpy.array) labels of cells, used for plotting.
        cutoff     - (string) threshold for filtering edges with scores less than cutoff.
        is_plot    - (boolean) if is_plot is True and labels are given, two plots of the
                     groupings and the pseudotimes will be displayed; if is_plot is True
                     and labels are None, only the plot of pseudotime will be displayed.
        path       - (string) path to save figure, or don&#39;t save if it is None.
    Returns:
        G          - (networkx.Graph) modified graph that indicates the inferred trajectory
        w          - (numpy.array) modified w_tilde
        pseudotime - (numpy.array) pseudotime based on projected trajectory
    &#39;&#39;&#39;
    # select edges
    if len(self.edges)==0:
        select_edges = []
        G = nx.Graph()
        G.add_nodes_from(self.G.nodes)
    else:
        if self.no_loop:
            G = nx.maximum_spanning_tree(self.G)
        else:
            G = self.G
        if cutoff is None:
            cutoff = 0.01
        graph = nx.to_numpy_matrix(G)
        graph[graph&lt;=cutoff] = 0
        G = nx.from_numpy_array(graph)
        connected_comps = nx.node_connected_component(G, init_node)
        subG = G.subgraph(connected_comps)
        if len(subG.edges)&gt;0:                
            milestone_net = self.build_milestone_net(subG,init_node)
            select_edges = milestone_net[:,:2]
            select_edges_score = graph[select_edges[:,0], select_edges[:,1]]
            if select_edges_score.max() - select_edges_score.min() == 0:
                select_edges_score = select_edges_score/select_edges_score.max()
            else:
                select_edges_score = (select_edges_score - select_edges_score.min())/(select_edges_score.max() - select_edges_score.min())*3                    
        else:
            milestone_net = select_edges = []                    
    
    # modify w_tilde
    w = self.modify_wtilde(self.w_tilde, select_edges)
    
    # compute pseudotime
    pseudotime = self.comp_pseudotime(milestone_net, init_node, w)
    
    if is_plot:
        fig, ax = plt.subplots(1,1, figsize=(20, 10))
            
        cmap = matplotlib.cm.get_cmap(&#39;viridis&#39;)
        colors = [plt.cm.jet(float(i)/self.NUM_CLUSTER) for i in range(self.NUM_CLUSTER)]
        if np.sum(pseudotime&gt;-1)&gt;0:
            norm = matplotlib.colors.Normalize(vmin=np.min(pseudotime[pseudotime&gt;-1]), vmax=np.max(pseudotime))
            sc = ax.scatter(*self.embed_z[pseudotime&gt;-1,:].T,
                norm=norm,
                c=pseudotime[pseudotime&gt;-1],
                s=8, alpha=0.5)
            plt.colorbar(sc, ax=[ax], location=&#39;right&#39;)
        else:
            norm = None
            
        if np.sum(pseudotime==-1)&gt;0:
            ax.scatter(*self.embed_z[pseudotime==-1,:].T,
                        c=&#39;gray&#39;, s=8, alpha=0.4)
        
        for i in range(len(select_edges)):
            points = self.embed_z[np.sum(w[:,select_edges[i,:]]&gt;0, axis=-1)==2,:]
            points = points[points[:,0].argsort()]                
            try:
                x_smooth, y_smooth = get_smooth_curve(
                    points, 
                    self.embed_mu[select_edges[i,:], :]
                    )
            except:
                x_smooth, y_smooth = self.embed_mu[select_edges[i,:], 0], self.embed_mu[select_edges[i,:], 1]
            ax.plot(x_smooth, y_smooth, 
                &#39;-&#39;, 
                linewidth= 1 + select_edges_score[0,i],
                color=&#34;black&#34;, 
                alpha=0.8, 
                path_effects=[pe.Stroke(linewidth=1+select_edges_score[0,i]+1.5, 
                                        foreground=&#39;white&#39;), pe.Normal()],
                zorder=1
                )

            delta_x = self.embed_mu[select_edges[i,1], 0]-x_smooth[-2]
            delta_y = self.embed_mu[select_edges[i,1], 1]-y_smooth[-2]
            length = np.sqrt(delta_x**2 + delta_y**2) * 1.5                
            ax.arrow(
                    self.embed_mu[select_edges[i,1], 0]-delta_x/length, 
                    self.embed_mu[select_edges[i,1], 1]-delta_y/length, 
                    delta_x/length,
                    delta_y/length,
                    color=&#39;black&#39;, alpha=1.0,
                    shape=&#39;full&#39;, lw=0, length_includes_head=True, head_width=0.4, zorder=2)
        
        for i in range(len(self.CLUSTER_CENTER)):
            ax.scatter(*self.embed_mu[i:i+1,:].T, c=[colors[i]],
                        edgecolors=&#39;white&#39;, # linewidths=10,
                        norm=norm,
                        s=250, marker=&#39;*&#39;, label=str(i))
            ax.text(self.embed_mu[i,0], self.embed_mu[i,1], &#39;%02d&#39;%i, fontsize=16)
            
        plt.setp(ax, xticks=[], yticks=[])
        box = ax.get_position()
        ax.set_position([box.x0, box.y0 + box.height * 0.1,
                            box.width, box.height * 0.9])
        ax.legend(loc=&#39;upper center&#39;, bbox_to_anchor=(0.5, -0.05),
            fancybox=True, shadow=True, ncol=5)
        
        ax.set_title(&#39;Trajectory&#39;)
        if path is not None:
            plt.savefig(path, dpi=300)
        plt.show()
    return G, w, pseudotime</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="VITAE" href="index.html">VITAE</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="VITAE.inference.Inferer" href="#VITAE.inference.Inferer">Inferer</a></code></h4>
<ul class="two-column">
<li><code><a title="VITAE.inference.Inferer.build_graphs" href="#VITAE.inference.Inferer.build_graphs">build_graphs</a></code></li>
<li><code><a title="VITAE.inference.Inferer.modify_wtilde" href="#VITAE.inference.Inferer.modify_wtilde">modify_wtilde</a></code></li>
<li><code><a title="VITAE.inference.Inferer.init_inference" href="#VITAE.inference.Inferer.init_inference">init_inference</a></code></li>
<li><code><a title="VITAE.inference.Inferer.init_embedding" href="#VITAE.inference.Inferer.init_embedding">init_embedding</a></code></li>
<li><code><a title="VITAE.inference.Inferer.plot_clusters" href="#VITAE.inference.Inferer.plot_clusters">plot_clusters</a></code></li>
<li><code><a title="VITAE.inference.Inferer.build_milestone_net" href="#VITAE.inference.Inferer.build_milestone_net">build_milestone_net</a></code></li>
<li><code><a title="VITAE.inference.Inferer.comp_pseudotime" href="#VITAE.inference.Inferer.comp_pseudotime">comp_pseudotime</a></code></li>
<li><code><a title="VITAE.inference.Inferer.infer_trajectory" href="#VITAE.inference.Inferer.infer_trajectory">infer_trajectory</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>